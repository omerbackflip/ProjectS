'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var urlParse = require('url-parse');
var isPlainObject = require('lodash/isPlainObject');
var mapValues = require('lodash/mapValues');

var defaultOptions = {
  percentage: 80,
  maskTimePropsNormally: false,
  maskFromRight: false,
  isMaskable: function isMaskable(value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    if (value === null) return true;
    return value instanceof Date || type !== 'object' && type !== 'function';
  }
};

var checkOptions = function checkOptions(options) {
  var exists = function exists(value) {
    return typeof value !== 'undefined';
  };

  var percentage = options.percentage,
      maskTimePropsNormally = options.maskTimePropsNormally,
      maskFromRight = options.maskFromRight;

  if (exists(percentage) && (Number.isNaN(Number(percentage)) || percentage < 0 || percentage > 100)) {
    throw new Error('Invalid percentage');
  }
  if (exists(maskTimePropsNormally) && typeof maskTimePropsNormally !== 'boolean') {
    throw new Error('maskTimePropsNormally must be a boolean');
  }
  if (exists(maskFromRight) && typeof maskFromRight !== 'boolean') {
    throw new Error('maskFromRight must be a boolean');
  }
};

var shouldBeEmptyString = function shouldBeEmptyString(key, maskTimePropsNormally) {
  return ['date', 'time'].some(function (word) {
    return String(key).toLowerCase().includes(word);
  }) && !maskTimePropsNormally;
};

var maskPrimitive = function maskPrimitive(value, key, options) {
  var percentage = options.percentage,
      maskTimePropsNormally = options.maskTimePropsNormally,
      maskFromRight = options.maskFromRight;

  /* Logging applications sometimes call new Date() on properties whose keys make them look like times/dates
    e.g. 'timeStamp' or 'createDate'. If called on an asterisked string this can lead to a wrong but misleading
    (and unmasked) date, so to be on the safe side return an empty string unless configured to do otherwise. */

  if (shouldBeEmptyString(key, maskTimePropsNormally)) return '';

  var arrayFromString = !maskFromRight ? String(value).split('') : String(value).split('').reverse();
  var valueLength = arrayFromString.length;
  if (valueLength <= 3) return '*'.repeat(valueLength);

  var indexToMaskTo = Math.round(valueLength * (percentage / 100)) - 1;
  var maskedString = arrayFromString.reduce(function (acc, char, i) {
    return '' + acc + (i <= indexToMaskTo ? '*' : arrayFromString[i]);
  }, '');

  if (maskFromRight) return maskedString.split('').reverse().join('');
  return maskedString;
};

var qsMask = function qsMask(value, keysToMask, options) {
  if (typeof value === 'string') {
    var parsedUrl = void 0;
    try {
      parsedUrl = urlParse(value, true);
    } catch (e) {
      // string is url with query and there is an un-decodable escape sequence in query, (e.g. '%E0%A4%A'). return with query chopped off
      return value.substring(0, value.indexOf('?'));
    }
    var qsKeysToMask = Object.keys(parsedUrl.query).filter(function (key) {
      return keysToMask.includes(key);
    });
    if (qsKeysToMask.length) {
      qsKeysToMask.forEach(function (keyToMask) {
        parsedUrl.query[keyToMask] = maskPrimitive(parsedUrl.query[keyToMask], keyToMask, options);
      });
      parsedUrl.set('query', parsedUrl.query);
      return parsedUrl.href;
    }
  }
  return null;
};

var maskDeep = function maskDeep(source, key, keysToMask, options) {
  if (options.isMaskable(source)) return maskPrimitive(source, key, options);
  if (Array.isArray(source)) return source.map(function (value, idx) {
    return maskDeep(value, idx, keysToMask, options);
  });

  if (isPlainObject(source)) {
    return mapValues(source, function (value, _key) {
      return maskDeep(value, _key, keysToMask, options);
    });
  }

  return source;
};

var findAndMask = function findAndMask(source, keysToMask) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  checkOptions(options);
  var finalOptions = Object.assign({}, defaultOptions, options);

  var topLevelQsMaskResult = qsMask(source, keysToMask, finalOptions);
  if (topLevelQsMaskResult) return topLevelQsMaskResult;
  if (finalOptions.isMaskable(source)) return source; // source is url with no offending query props or it's just stringlike - so we're just returning it.

  var propertyHandler = function propertyHandler(value, key) {
    var qsMaskResult = qsMask(value, keysToMask, finalOptions);
    if (qsMaskResult) {
      value = qsMaskResult;
    }
    if (keysToMask.includes(key)) return maskDeep(value, key, keysToMask, finalOptions);
    if (isPlainObject(value) || Array.isArray(value)) return findAndMask(value, keysToMask, options);

    return value;
  };
  if (Array.isArray(source)) return source.map(propertyHandler);
  return mapValues(source, propertyHandler);
};

module.exports = findAndMask;