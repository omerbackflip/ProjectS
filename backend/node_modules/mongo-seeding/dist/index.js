"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
const database_1 = require("./database");
const transformer_1 = require("./transformer");
const importer_1 = require("./importer");
const config_1 = require("./config");
__export(require("./config"));
__export(require("./helpers"));
/**
 * Allows to seed database. It is a main Mongo Seeding class.
 */
class Seeder {
    /**
     * Constructs a new `Seeder` instance and loads configuration for data import.
     *
     * @param config Optional partial object with database seeding configuration. The object is merged with the default configuration object. To use all default settings, simply omit this parameter.
     */
    constructor(config) {
        /**
         * Configuration for seeding database.
         */
        this.config = config_1.defaultSeederConfig;
        /**
         * Populates collections and their documents from given path.
         * The path has to contain file structure described on https://github.com/pkosiec/mongo-seeding/blob/master/docs/import-data-definition.md.
         *
         * @param path File path
         * @param partialConfig Optional partial collection reading configuration object. It is merged with default configuration object. To use all default settings, simply omit this parameter.
         */
        this.readCollectionsFromPath = (path, partialConfig) => {
            const config = config_1.mergeCollectionReadingOptions(partialConfig);
            let collections;
            try {
                const { CollectionPopulator } = require('./populator');
                const populator = new CollectionPopulator(config.extensions, this.log);
                this.log(`Reading collections from ${path}...`);
                collections = populator.readFromPath(path);
            }
            catch (err) {
                throw wrapError(err);
            }
            if (config.transformers.length > 0) {
                this.log('Transforming collections...');
                collections = new transformer_1.CollectionTransformer().transform(collections, config.transformers);
            }
            return collections;
        };
        /**
         * Connects to a database and imports all collections.
         *
         * @param collections Array of collection definitions
         * @param partialConfig Optional partial configuration object. Ita allows to change the database seeding configuration for single data import.   It is merged with default configuration object. To use the configuration provided in `Seeder` constructor, simply omit this parameter.
         */
        this.import = (collections, partialConfig) => __awaiter(this, void 0, void 0, function* () {
            if (collections.length === 0) {
                this.log('No data to import. Finishing...');
                return;
            }
            this.log('Starting collection import...');
            const config = config_1.mergeSeederConfig(partialConfig, this.config);
            const databaseConnector = new database_1.DatabaseConnector(config.databaseReconnectTimeout, config.mongoClientOptions, this.log);
            try {
                const database = yield databaseConnector.connect(config.database);
                if (!config.dropDatabase && config.dropCollections) {
                    this.log('Dropping collections...');
                    for (const collection of collections) {
                        yield database.dropCollectionIfExists(collection.name);
                    }
                }
                if (config.dropDatabase) {
                    this.log('Dropping database...');
                    yield database.drop();
                }
                yield new importer_1.CollectionImporter(database, config.collectionInsertManyOptions, this.log).import(collections);
            }
            catch (err) {
                throw wrapError(err);
            }
            finally {
                yield databaseConnector.close();
            }
            this.log('Finishing...');
        });
        this.config = config_1.mergeSeederConfig(config);
        this.log = common_1.NewLoggerInstance();
    }
}
exports.Seeder = Seeder;
/**
 * Transformer functions for collections before data import.
 */
Seeder.Transformers = transformer_1.DefaultTransformers;
/**
 * Wraps error with custom name
 *
 * @param err Original error
 */
const wrapError = (err) => {
    const error = new Error(`${err.name}: ${err.message}`);
    error.name = 'MongoSeedingError';
    return error;
};
//# sourceMappingURL=index.js.map